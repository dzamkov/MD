namespace MD

open Util
open System
open System.IO

/// An interface to a reader for items of a certain blittable type.
[<AbstractClass>]
type Stream<'a when 'a : unmanaged> (alignment : int) =

    /// Gets the alignment of this stream. This is the smallest amount of items the stream can
    /// individually access. All read operations should have a size that is some multiple of
    /// this integer.
    member this.Alignment = alignment

    /// Copies items from this stream into a array and returns the amount of
    /// items read. If the returned amount is under the requested size, the end of
    /// the stream has been reached.
    abstract member ReadArray : array : 'a[] * offset : int * size : int -> int

    /// Copies items from this stream to the given buffer and returns the amount
    /// of items read. If the returned amount is under the requested size, the end of
    /// the stream has been reached.
    abstract member ReadBuffer : buffer : Buffer<'a> * size : int -> int

/// A stream that reads from an array.
type ArrayStream<'a when 'a : unmanaged> (array : 'a[], offset : int) =
    inherit Stream<'a> (1)
    let mutable offset = offset

    /// Gets the array this stream is reading from.
    member this.Array = array

    /// Gets the current offset of the stream in the source array.
    member this.Offset = offset

    override this.ReadArray (targetArray, targetOffset, size) =
        let readSize = min size (array.Length - offset)
        Array.blit array offset targetArray targetOffset readSize
        offset <- offset + readSize
        readSize

    override this.ReadBuffer (buffer, size) =
        let readSize = min size (array.Length - offset)
        buffer.CopyFrom (array, offset, size)
        offset <- offset + readSize
        readSize

/// A stream that reads from a buffer.
[<Sealed>]
type BufferStream<'a when 'a : unmanaged> (buffer : Buffer<'a>) =
    inherit Stream<'a> (1)
    let mutable buffer = buffer

    /// Gets the current buffer this stream is reading from. Note that this buffer
    /// advances in memory location with each read operation.
    member this.Buffer = buffer

    override this.ReadArray (array, offset, size) =
        buffer.CopyTo (array, offset, size)
        buffer <- buffer.Advance size
        size

    override this.ReadBuffer (targetBuffer, size) =
        buffer.CopyTo (targetBuffer, size)
        buffer <- buffer.Advance size
        size

/// A stream that limits the amount of items that can be read.
[<Sealed>]
type LimitStream<'a when 'a : unmanaged> (source : Stream<'a>, size : uint64) =
    inherit Stream<'a> (source.Alignment)
    let mutable size = size

    /// Gets the remaining size of this stream.
    member this.Size = size

    override this.ReadArray (array, offset, readSize) =
        let readSize = source.ReadArray (array, offset, int (min (uint64 readSize) (uint64 size)))
        size <- size - uint64 readSize
        readSize

    override this.ReadBuffer (buffer, readSize) =
        let readSize = source.ReadBuffer (buffer, int (min (uint64 readSize) (uint64 size)))
        size <- size - uint64 readSize
        readSize

/// A stream that reads through streams (called chunks) generated by a retrieve function.
[<Sealed>]
type ChunkStream<'a, 'b when 'a : unmanaged> (alignment : int, initial : (Stream<'a> exclusive * 'b) option, retrieve : 'b -> (Stream<'a> exclusive * 'b) option) =
    inherit Stream<'a> (alignment)
    let mutable current = initial
    new (alignment, initialState : 'b, retrieve : 'b -> (Stream<'a> exclusive * 'b) option) = new ChunkStream<'a, 'b> (alignment, retrieve initialState, retrieve)

    /// Gets the function used for retrieving chunks.
    member this.Retrieve = retrieve

    /// Releases this stream and all subordinate chunk streams.
    member this.Finish () =
        match current with
        | Some (stream, _) -> stream.Finish ()
        | None -> ()

    override this.ReadArray (array, offset, size) = 
        let rec read (array : 'a[], offset: int, size : int) (totalReadSize : int) =
            match current with
            | Some (stream, state) ->
                let readSize = stream.Object.ReadArray (array, offset, size)
                if readSize < size then
                    stream.Finish ()
                    current <- retrieve state
                    read (array, offset + readSize, size - readSize) (totalReadSize + readSize)
                else totalReadSize + size
            | None -> totalReadSize
        read (array, offset, size) 0

    override this.ReadBuffer (buffer, size) = 
        let itemSize = Memory.SizeOf<'a> ()
        let rec read (buffer, size : int) (totalReadSize : int) =
            match current with
            | Some (stream, state) ->
                let readSize = stream.Object.ReadBuffer (buffer, size)
                if readSize < size then
                    stream.Finish ()
                    current <- retrieve state
                    read (buffer.Advance readSize, size - readSize) (totalReadSize + readSize)
                else totalReadSize + size
            | None -> totalReadSize
        read (buffer, size) 0

/// A stream that maps items with a mapping function.
[<Sealed>]
type MapStream<'a, 'b when 'a : unmanaged and 'b : unmanaged> (source : Stream<'b>, map : 'b -> 'a) =
    inherit Stream<'a> (source.Alignment)
    let chunk = Array.zeroCreate base.Alignment
    let loadChunk () = source.ReadArray (chunk, 0, chunk.Length) = chunk.Length

    override this.ReadArray (array, offset, size) = 
        let mutable size = size
        let mutable cur = offset
        while size > 0 && loadChunk() do
            for index = 0 to chunk.Length - 1 do
                array.[cur] <- map chunk.[index]
                cur <- cur + 1
            size <- size - chunk.Length
        cur - offset

    override this.ReadBuffer (buffer, size) = 
        let mutable buffer = buffer
        let mutable size = size
        let mutable cur = 0
        while size > 0 && loadChunk() do
            for index = 0 to this.Alignment - 1 do
                buffer.[cur] <- map chunk.[index]
                cur <- cur + 1
            size <- size - this.Alignment
        cur

/// A stream that combines fixed-size groups of items into single items.
[<Sealed>]
type CombineStream<'a, 'b when 'a : unmanaged and 'b : unmanaged> (source : Stream<'b>, groupSize : int, combine : 'b[] * int -> 'a) =
    inherit Stream<'a> (fit groupSize source.Alignment)
    let chunk = Array.zeroCreate (base.Alignment * groupSize)
    let loadChunk () = source.ReadArray (chunk, 0, chunk.Length) = chunk.Length

    override this.ReadArray (array, offset, size) = 
        let mutable size = size
        let mutable cur = offset
        while size > 0 && loadChunk() do
            for index = 0 to this.Alignment - 1 do
                array.[cur] <- combine (chunk, index * groupSize)
                cur <- cur + 1
            size <- size - this.Alignment
        cur - offset

    override this.ReadBuffer (buffer, size) = 
        let mutable buffer = buffer
        let mutable size = size
        let mutable cur = 0
        while size > 0 && loadChunk() do
            for index = 0 to this.Alignment - 1 do
                buffer.[index] <- combine (chunk, index * groupSize)
                cur <- cur + 1
            size <- size - this.Alignment
        cur

/// A stream that splits single items into fixed-size groups.
[<Sealed>]
type SplitStream<'a, 'b when 'a : unmanaged and 'b : unmanaged> (source : Stream<'b>, groupSize : int, split : 'b * 'a[] * int -> unit) =
    inherit Stream<'a> (source.Alignment * groupSize)
    let chunk = Array.zeroCreate (source.Alignment)
    let loadChunk () = source.ReadArray (chunk, 0, chunk.Length) = chunk.Length

    override this.ReadArray (array, offset, size) =
        let mutable size = size
        let mutable cur = offset
        while size > 0 && loadChunk() do
            for index = 0 to chunk.Length - 1 do
                split (chunk.[index], array, cur)
                cur <- cur + groupSize
            size <- size - this.Alignment
        cur - offset

    override this.ReadBuffer (buffer, size) =
        let initialSize = size
        let mutable buffer = buffer
        let mutable size = size
        let mutable cur = 0
        let tempArray = Array.zeroCreate (this.Alignment)
        while size > 0 && loadChunk() do
            for index = 0 to chunk.Length - 1 do
                split (chunk.[index], tempArray, index * groupSize)
                buffer.CopyFrom (tempArray, 0, groupSize)
                buffer <- buffer.Advance groupSize
            size <- size - this.Alignment
        initialSize - size

/// A stream that cast items in a source stream by reinterpreting the byte representations of sequential items.
[<Sealed>]
type CastStream<'a, 'b when 'a : unmanaged and 'b : unmanaged> (source : Stream<'b>, asize : uint32, bsize : uint32) =
    inherit Stream<'a> (fit (int asize) (source.Alignment * int bsize))
    new (source) = new CastStream<'a, 'b> (source, Memory.SizeOf<'a> (), Memory.SizeOf<'b> ())
    
    override this.ReadArray (array, offset, size) = 
        let sourceSize = size * int asize / int bsize
        let readArray = Array.zeroCreate sourceSize
        let readSize = source.ReadArray (readArray, 0, sourceSize)
        Memory.Copy (readArray, 0, array, offset, bsize * uint32 readSize)
        readSize * int bsize / int asize

    override this.ReadBuffer (buffer, size) = source.ReadBuffer (buffer.Cast (), size * int asize / int bsize) * int bsize / int asize

/// A byte stream based on a System.IO stream.
[<Sealed>]
type IOStream (source : Stream) =
    inherit Stream<byte> (1)

    /// Gets the System.IO stream source for this stream.
    member this.Source = source

    override this.ReadArray (array, offset, size) = source.Read (array, offset, size)

    override this.ReadBuffer (buffer, size) =
        let readArray = Array.zeroCreate size
        let readSize = source.Read (readArray, 0, size)
        buffer.CopyFrom (readArray, 0, readSize)
        readSize

/// Contains functions for constructing and manipulating streams.
module Stream =

    /// Reads the given amount of items from a stream into an array. If the stream does not have the requested
    /// amount of items, a smaller array of only the read items will be returned.
    let read size (stream : Stream<'a>) =
        let array = Array.zeroCreate size
        let readSize = stream.ReadArray (array, 0, size)
        if readSize < size then
            let newArray = Array.zeroCreate readSize
            Array.blit array 0 newArray 0 readSize
            newArray
        else array

    /// Constructs a stream to read from a buffer. Note that the buffer is referenced directly and 
    /// changes to the buffer will be reflected in the stream.
    let buffer buffer = new BufferStream<'a> (buffer) :> Stream<'a>

    /// Constructs a stream to read from an array. Note that the array is referenced directly and 
    /// changes to the array will be reflected in the stream.
    let array array offset = new ArrayStream<'a> (array, offset) :> Stream<'a>

    /// Constructs a stream to read from the file at the given path.
    let file (path : MD.Path) =
        let fs = new FileStream (path.Source, FileMode.Open)
        let is = new IOStream (fs) :> Stream<byte>
        Exclusive.custom (fun x -> fs.Dispose ()) is

    /// Constructs a stream that concatenates a series of chunks produced by the given retrieve function.
    let chunk alignment (initial : 'b) retrieve = 
        let cs = new ChunkStream<'a, 'b> (alignment, initial, retrieve)
        cs |> Exclusive.custom (fun cs -> cs.Finish ()) |> Exclusive.map (fun x -> x :> Stream<'a>)

    /// Constructs a stream that concatenates a series of chunks produced by the given retrieve function. The initial chunk
    /// must be provided when using this function.
    let chunkInit alignment (initial : (Stream<'a> exclusive * 'b) option) retrieve = 
        let cs = new ChunkStream<'a, 'b> (alignment, initial, retrieve)
        cs |> Exclusive.custom (fun cs -> cs.Finish ()) |> Exclusive.map (fun x -> x :> Stream<'a>)

    /// Constructs a mapped form of a stream.
    let map map source = new MapStream<'a, 'b> (source, map) :> Stream<'a>

    /// Constructs a stream that combines fixed-sized groups into single items.
    let combine groupSize group source = new CombineStream<'a, 'b> (source, groupSize, group) :> Stream<'a>

    /// Constructs a stream that splits single items into fixed-sized groups.
    let split groupSize split source = new SplitStream<'a, 'b> (source, groupSize, split) :> Stream<'a>

    /// Constructs a stream based on a source stream that reinterprets the byte representations of source items in order
    /// to form items of other types.
    let cast (source : Stream<'b>) =
        match source with
        | :? BufferStream<'b> as source -> new BufferStream<'a> (source.Buffer.Cast ()) :> Stream<'a>
        | _ -> new CastStream<'a, 'b> (source) :> Stream<'a>

    /// Constructs a size-limited form of the given stream.
    let limit size source = new LimitStream<'a> (source, size) :> Stream<'a>