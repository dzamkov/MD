namespace MD

open System
open System.IO
open Microsoft.FSharp.NativeInterop

/// An interface to a reader for items of a certain type.
[<AbstractClass>]
type Stream<'a> () =

    /// Tries reading a single item from this stream. Returns None if the end of the stream has
    /// been reached.
    abstract member Read : unit -> 'a option

    /// Copies items from this stream into a native array and returns the amount of
    /// items read. If the returned amount is under the requested size, the end of
    /// the stream has been reached.
    abstract member Read : buffer : 'a[] * offset : int * size : int -> int

    /// Copies items from this stream to the given memory location and returns the amount
    /// of items read. If the returned amount is under the requested size, the end of
    /// the stream has been reached. This should only be used for blittable types.
    abstract member Read : destination : nativeint * size : int -> int

// Create type abbreviation.
type 'a stream = Stream<'a>

/// A stream that reads from a buffer (array).
[<Sealed>]
type BufferStream<'a> (buffer : 'a[], offset : int) =
    inherit Stream<'a> ()
    let mutable offset = offset

    /// Gets the buffer this stream is reading from.
    member this.Buffer = buffer

    /// Gets the current offset of the stream in the source buffer.
    member this.Offset = offset

    override this.Read () = 
        if offset < buffer.Length then
            let item = buffer.[offset]
            offset <- offset + 1
            Some item
        else None

    override this.Read (destbuffer, destoffset, size) =
        let readsize = min size (buffer.Length - offset)
        Array.blit buffer offset destbuffer destoffset readsize
        offset <- offset + readsize
        readsize

    override this.Read (destination, size) =
        let readsize = min size (buffer.Length - offset)
        Memory.Copy (buffer, offset, destination, uint32 readsize)
        offset <- offset + readsize
        readsize

/// A stream that limits the amount of items that can be read.
[<Sealed>]
type LimitStream<'a> (source : 'a stream, size : int) =
    inherit Stream<'a> ()
    let mutable size = size

    /// Gets the remaining size of this stream.
    member this.Size = size

    override this.Read () = 
        if size > 0 then
            match source.Read () with 
            | Some item ->
                size <- size - 1
                Some item
            | None -> None
        else None

    override this.Read (buffer, offset, rsize) =
        let mutable readsize = min rsize size
        readsize <- source.Read (buffer, offset, readsize)
        size <- size - readsize
        readsize

    override this.Read (destination, rsize) =
        let mutable readsize = min rsize size
        readsize <- source.Read (destination, readsize)
        size <- size - readsize
        readsize

/// A stream that reads through streams (called chunks) generated by a retrieve function.
[<Sealed>]
type ChunkStream<'a, 'b> (initial : ('a stream exclusive * 'b) option, retrieve : 'b -> ('a stream exclusive * 'b) option) =
    inherit Stream<'a> ()
    let mutable current = initial
    new (initialState : 'b, retrieve : 'b -> ('a stream exclusive * 'b) option) = new ChunkStream<'a, 'b> (retrieve initialState, retrieve)

    /// Gets the function used for retrieving chunks.
    member this.Retrieve = retrieve

    /// Releases this stream and all subordinate chunk streams.
    member this.Finish () =
        match current with
        | Some (stream, _) -> stream.Finish ()
        | None -> ()

    override this.Read () =
        let rec read () =
            match current with
            | Some (stream, state) ->
                match stream.Object.Read () with
                | Some x -> Some x
                | None -> 
                    stream.Finish ()
                    current <- retrieve state
                    read ()
            | None -> None
        read ()

    override this.Read (buffer, offset, size) = 
        let rec read (buffer : 'a[], offset: int, size : int) (totalreadsize : int) =
            match current with
            | Some (stream, state) ->
                let readsize = stream.Object.Read (buffer, offset, size)
                if readsize < size then
                    stream.Finish ()
                    current <- retrieve state
                    read (buffer, offset + readsize, size - readsize) (totalreadsize + readsize)
                else totalreadsize + size
            | None -> totalreadsize
        read (buffer, offset, size) 0

    override this.Read (destination, size) = 
        let rec read (destination : nativeint, size : int) (totalreadsize : int) =
            match current with
            | Some (stream, state) ->
                let readsize = stream.Object.Read (destination, size)
                if readsize < size then
                    stream.Finish ()
                    current <- retrieve state
                    read (destination + nativeint (Memory.SizeOf<'a> () * uint32 readsize), size - readsize) (totalreadsize + readsize)
                else totalreadsize + size
            | None -> totalreadsize
        read (destination, size) 0


/// A stream that combines fixed size groups in a source stream.
[<Sealed>]
type CombineStream<'a, 'b> (source : 'b stream, groupSize : int, group : 'b[] -> 'a) =
    inherit Stream<'a> ()
    let buf : 'b[] = Array.zeroCreate groupSize
    let loadone () = source.Read (buf, 0, groupSize) = groupSize
    let readone () = group buf

    override this.Read () = if loadone () then Some (readone ()) else None

    override this.Read (buffer, offset, size) = 
        let mutable size = size
        let mutable cur = offset
        while size > 0 && loadone() do
            buffer.[cur] <- readone()
            cur <- cur + 1
            size <- size - 1
        cur - offset

    override this.Read (destination, size) = 
        let itemsize = Memory.SizeOf<'a> ()
        let initsize = size
        let mutable size = size
        let mutable cur = destination
        while size > 0 && loadone() do
            Memory.Write (cur, readone())
            cur <- cur + nativeint (itemsize)
            size <- size - 1
        initsize - size

/// A byte stream whose source is a region of memory.
[<Sealed>]
type UnsafeStream<'a when 'a : unmanaged> (regionStart : nativeint, regionEnd : nativeint) =
    inherit Stream<'a> ()
    let mutable cur = regionStart
    let itemsize = Memory.SizeOf<'a> ()

    /// Gets the remaining size of the stream.
    member this.Size = int32 (uint32 (regionEnd - cur) / itemsize)

    /// Gets the pointer to the current position of the stream.
    member this.Current = cur

    /// Gets the end of the memory region readable by the stream.
    member this.End = regionEnd

    override this.Read () =
        let next = cur + nativeint itemsize
        if next <= regionEnd then
            let item = Memory.Read cur
            cur <- next
            Some item
        else None

    override this.Read (buffer, offset, size) =
        let readsize = min size this.Size
        Memory.Copy (cur, buffer, offset, uint32 readsize)
        cur <- cur + nativeint (uint32 readsize * itemsize)
        readsize

    override this.Read (destination, size) =
        let readsize = min size this.Size
        Memory.Copy (cur, destination, uint32 readsize)
        cur <- cur + nativeint (uint32 readsize * itemsize)
        readsize

/// A byte stream based on a System.IO stream.
[<Sealed>]
type IOStream (source : Stream) =
    inherit Stream<byte> ()

    /// Gets the System.IO stream source for this stream.
    member this.Source = source

    override this.Read () =
        match source.ReadByte () with
        | -1 -> None
        | x -> Some (byte x)

    override this.Read (buffer, offset, size) = source.Read (buffer, offset, size)

    override this.Read (destination, size) =
        let readbuffer = Array.zeroCreate size
        let readsize = source.Read (readbuffer, 0, size)
        Memory.Copy (readbuffer, 0, destination, uint32 readsize)
        readsize

/// Contains functions for constructing and manipulating streams.
module Stream =

    /// Reads the given amount of items from a stream into a buffer. If the stream does not have the requested
    /// amount of items, a smaller buffer of only the read items will be returned.
    let read size (stream : 'a stream) =
        let buf = Array.zeroCreate size
        let readsize = stream.Read (buf, 0, size)
        if readsize < size then
            let nbuf = Array.zeroCreate readsize
            Array.blit buf 0 nbuf 0 readsize
            nbuf
        else buf

    /// Constructs a stream to read from a buffer. Note that the buffer is referenced directly and 
    /// changes to the buffer will be reflected in the stream.
    let buffer buffer offset = new BufferStream<'a> (buffer, offset)

    /// Constructs a stream to read from the file at the given path.
    let file (path : MD.Path) =
        let fs = new FileStream (path.Source, FileMode.Open)
        let is = new IOStream (fs) :> byte stream
        Exclusive.custom fs.Dispose is

    /// Constructs a stream that concatenates a series of chunks produced by the given retrieve function.
    let chunk (initial : 'b) retrieve = 
        let cs = new ChunkStream<'a, 'b> (initial, retrieve)
        Exclusive.custom cs.Finish (cs :> 'a stream)

    /// Constructs a stream that concatenates a series of chunks produced by the given retrieve function. The initial chunk
    /// must be provided when using this function.
    let chunkInit (initial : ('a stream exclusive * 'b) option) retrieve = 
        let cs = new ChunkStream<'a, 'b> (initial, retrieve)
        Exclusive.custom cs.Finish (cs :> 'a stream)

    /// Constructs a stream that combines fixed-sized groups in the source stream into single items.
    let combine groupSize group source = new CombineStream<'a, 'b> (source, groupSize, group) :> 'a stream

    /// Constructs a size-limited form of the given stream.
    let limit size source = new LimitStream<'a> (source, size) :> 'a stream

    /// Constructs a stream that reads from the given memory region.
    let unsafe regionStart regionEnd = new UnsafeStream<'a> (regionStart, regionEnd) :> 'a stream